<p>For more than a decade the Web has used XMLHttpRequest (XHR) to achieve
                            asynchronous requests in JavaScript. While very useful, XHR is not a very
                            nice API. It suffers from lack of separation of concerns. The input, output
                            and state are all managed by interacting with one object, and state is
                            tracked using events. Also, the event-based model doesn’t play well with
                            JavaScript’s recent focus on Promise- and generator-based asynchronous
                            programming.</p><p>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a> intends
                            to fix most of these problems. It does this by introducing the same primitives
                            to JS that are used in the HTTP protocol. In addition, it introduces a
                            utility function <code>fetch()</code> that succinctly captures the intention
                            of retrieving a resource from the network.</p><p>The <a href="https://fetch.spec.whatwg.org">Fetch specification</a>, which
                            defines the API, nails down the semantics of a user agent fetching a resource.
                            This, combined with ServiceWorkers, is an attempt to:</p><p>As of this writing, the Fetch API is available in Firefox 39 (currently
                            Nightly) and Chrome 42 (currently dev). Github has a <a href="https://github.com/github/fetch">Fetch polyfill</a>.</p><h2>Feature detection</h2><p>Fetch API support can be detected by checking for <code>Headers</code>,<code>Request</code>, <code>Response</code> or <code>fetch</code> on
                            the <code>window</code> or <code>worker</code> scope.</p><h2>Simple fetching</h2><p>The most useful, high-level part of the Fetch API is the <code>fetch()</code> function.
                            In its simplest form it takes a URL and returns a promise that resolves
                            to the response. The response is captured as a <code>Response</code> object.</p><p>Submitting some parameters, it would look like this:</p><p>The <code>fetch()</code> function’s arguments are the same as those passed
                to the
                <br/>
<code>Request()</code> constructor, so you may directly pass arbitrarily
                complex requests to <code>fetch()</code> as discussed below.</p><h2>Headers</h2><p>Fetch introduces 3 interfaces. These are <code>Headers</code>, <code>Request</code> and
            <br/>
<code>Response</code>. They map directly to the underlying HTTP concepts,
                but have
                <br/>certain visibility filters in place for privacy and security reasons,
                such as
                <br/>supporting CORS rules and ensuring cookies aren’t readable by third parties.</p><p>The <a href="https://fetch.spec.whatwg.org/#headers-class">Headers interface</a> is
                a simple multi-map of names to values:</p><p>The same can be achieved by passing an array of arrays or a JS object
                literal
                <br/>to the constructor:</p><p>The contents can be queried and retrieved:</p><p>Some of these operations are only useful in ServiceWorkers, but they provide
            <br/>a much nicer API to Headers.</p><p>Since Headers can be sent in requests, or received in responses, and have
                various limitations about what information can and should be mutable, <code>Headers</code> objects
                have a <strong>guard</strong> property. This is not exposed to the Web, but
                it affects which mutation operations are allowed on the Headers object.
                <br/>Possible values are:</p><p>The details of how each guard affects the behaviors of the Headers object
                are
                <br/>in the <a href="https://fetch.spec.whatwg.org">specification</a>. For example,
                you may not append or set a “request” guarded Headers’ “Content-Length”
                header. Similarly, inserting “Set-Cookie” into a Response header is not
                allowed so that ServiceWorkers may not set cookies via synthesized Responses.</p><p>All of the Headers methods throw TypeError if <code>name</code> is not a
                <a href="https://fetch.spec.whatwg.org/#concept-header-name">valid HTTP Header name</a>. The mutation operations will throw TypeError
                    if there is an immutable guard. Otherwise they fail silently. For example:</p><h2>Request</h2><p>The Request interface defines a request to fetch a resource over HTTP.
            URL, method and headers are expected, but the Request also allows specifying
            a body, a request mode, credentials and cache hints.</p><p>The simplest Request is of course, just a URL, as you may do to GET a
            resource.</p><p>You may also pass a Request to the <code>Request()</code> constructor to
            create a copy.
            <br/>(This is not the same as calling the <code>clone()</code> method, which
            is covered in
            <br/>the “Reading bodies” section.).</p><p>Again, this form is probably only useful in ServiceWorkers.</p><p>The non-URL attributes of the <code>Request</code> can only be set by passing
            initial
            <br/>values as a second argument to the constructor. This argument is a dictionary.</p><p>The Request’s mode is used to determine if cross-origin requests lead
                to valid responses, and which properties on the response are readable.
                Legal mode values are <code>&#34;same-origin&#34;</code>, <code>&#34;no-cors&#34;</code> (default)
                and <code>&#34;cors&#34;</code>.</p><p>The <code>&#34;same-origin&#34;</code> mode is simple, if a request is made to another
                origin with this mode set, the result is simply an error. You could use
                this to ensure that
                <br/>a request is always being made to your origin.</p><p>The <code>&#34;no-cors&#34;</code> mode captures what the web platform does by default
                for scripts you import from CDNs, images hosted on other domains, and so
                on. First, it prevents the method from being anything other than “HEAD”,
                “GET” or “POST”. Second, if any ServiceWorkers intercept these requests,
                they may not add or override any headers except for <a href="https://fetch.spec.whatwg.org/#simple-header">these</a>.
                Third, JavaScript may not access any properties of the resulting Response.
                This ensures that ServiceWorkers do not affect the semantics of the Web
                and prevents security and privacy issues that could arise from leaking
                data across domains.</p><p><code>&#34;cors&#34;</code> mode is what you’ll usually use to make known cross-origin
                requests to access various APIs offered by other vendors. These are expected
                to adhere to
                <br/>the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS">CORS protocol</a>.
                Only a <a href="https://fetch.spec.whatwg.org/#concept-filtered-response-cors">limited set</a> of
                headers is exposed in the Response, but the body is readable. For example,
                you could get a list of Flickr’s <a href="https://www.flickr.com/services/api/flickr.interestingness.getList.html">most interesting</a> photos
                today like this:</p><p>You may not read out the “Date” header since Flickr does not allow it
                via
                <br/>
<code>Access-Control-Expose-Headers</code>.</p><p>The <code>credentials</code> enumeration determines if cookies for the other
                domain are
                <br/>sent to cross-origin requests. This is similar to XHR’s <code>withCredentials</code>
                <br/>flag, but tri-valued as <code>&#34;omit&#34;</code> (default), <code>&#34;same-origin&#34;</code> and <code>&#34;include&#34;</code>.</p><p>The Request object will also give the ability to offer caching hints to
                the user-agent. This is currently undergoing some <a href="https://github.com/slightlyoff/ServiceWorker/issues/585">security review</a>.
                Firefox exposes the attribute, but it has no effect.</p><p>Requests have two read-only attributes that are relevant to ServiceWorkers
            <br/>intercepting them. There is the string <code>referrer</code>, which is
                set by the UA to be
                <br/>the referrer of the Request. This may be an empty string. The other is
                <br/>
<code>context</code> which is a rather <a href="https://fetch.spec.whatwg.org/#requestcredentials">large enumeration</a> defining
                what sort of resource is being fetched. This could be “image” if the request
                is from an
                &lt;img&gt;tag in the controlled document, “worker” if it is an attempt to load a
                worker script, and so on. When used with the <code>fetch()</code> function,
                it is “fetch”.</p><h2>Response</h2><p><code>Response</code> instances are returned by calls to <code>fetch()</code>.
                They can also be created by JS, but this is only useful in ServiceWorkers.</p><p>We have already seen some attributes of Response when we looked at <code>fetch()</code>.
                The most obvious candidates are <code>status</code>, an integer (default
                value 200) and <code>statusText</code> (default value “OK”), which correspond
                to the HTTP status code and reason. The <code>ok</code> attribute is just
                a shorthand for checking that <code>status</code> is in the range 200-299
                inclusive.</p><p><code>headers</code> is the Response’s Headers object, with guard “response”.
                The <code>url</code> attribute reflects the URL of the corresponding request.</p><p>Response also has a <code>type</code>, which is “basic”, “cors”, “default”,
                “error” or
                <br/>“opaque”.</p><p>The “error” type results in the <code>fetch()</code> Promise rejecting with
                TypeError.</p><p>There are certain attributes that are useful only in a ServiceWorker scope.
                The
                <br/>idiomatic way to return a Response to an intercepted request in ServiceWorkers
                is:</p><p>As you can see, Response has a two argument constructor, where both arguments
                are optional. The first argument is a body initializer, and the second
                is a dictionary to set the <code>status</code>, <code>statusText</code> and <code>headers</code>.</p><p>The static method <code>Response.error()</code> simply returns an error
                response. Similarly, <code>Response.redirect(url, status)</code> returns
                a Response resulting in
                <br/>a redirect to <code>url</code>.</p><h2>Dealing with bodies</h2><p>Both Requests and Responses may contain body data. We’ve been glossing
                over it because of the various data types body may contain, but we will
                cover it in detail now.</p><p>A body is an instance of any of the following types.</p><p>In addition, Request and Response both offer the following methods to
                extract their body. These all return a Promise that is eventually resolved
                with the actual content.</p><p>This is a significant improvement over XHR in terms of ease of use of
                non-text data!</p><p>Request bodies can be set by passing <code>body</code> parameters:</p><p>Responses take the first argument as the body.</p><p>Both Request and Response (and by extension the <code>fetch()</code> function),
                    will try to intelligently <a href="https://fetch.spec.whatwg.org/#concept-bodyinit-extract">determine the content type</a>.
                    Request will also automatically set a “Content-Type” header if none is
                    set in the dictionary.</p><h3>Streams and cloning</h3><p>It is important to realise that Request and Response bodies can only be
                    read once! Both interfaces have a boolean attribute <code>bodyUsed</code> to
                    determine if it is safe to read or not.</p><p>This decision allows easing the transition to an eventual <a href="https://streams.spec.whatwg.org/">stream-based</a> Fetch
                    API. The intention is to let applications consume data as it arrives, allowing
                    for JavaScript to deal with larger files like videos, and perform things
                    like compression and editing on the fly.</p><p>Often, you’ll want access to the body multiple times. For example, you
                    can use the upcoming <a href="http://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#cache-objects">Cache API</a> to
                    store Requests and Responses for offline use, and Cache requires bodies
                    to be available for reading.</p><p>So how do you read out the body multiple times within such constraints?
                    The API provides a <code>clone()</code> method on the two interfaces. This
                    will return a clone of the object, with a ‘new’ body. <code>clone()</code> MUST
                    be called before the body of the corresponding object has been used. That
                    is, <code>clone()</code> first, read later.</p><h2>Future improvements</h2><p>Along with the transition to streams, Fetch will eventually have the ability
                    to abort running <code>fetch()</code>es and some way to report the progress
                    of a fetch. These are provided by XHR, but are a little tricky to fit in
                    the Promise-based nature of the Fetch API.</p><p>You can contribute to the evolution of this API by participating in discussions
                    on the <a href="https://whatwg.org/mailing-list">WHATWG mailing list</a> and
                    in the issues in the <a href="https://www.w3.org/Bugs/Public/buglist.cgi?product=WHATWG&amp;component=Fetch&amp;resolution=---">Fetch</a> and
                    <a href="https://github.com/slightlyoff/ServiceWorker/issues">ServiceWorker</a>specifications.</p><p>For a better web!</p><p><em>The author would like to thank Andrea Marchesini, Anne van Kesteren and Ben<br/>
Kelly for helping with the specification and implementation.</em>
                </p>